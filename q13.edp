int i=0;

//Module de Young (toujours positif)
real E=15.;	
		
//Coefficient de Poisson (entre -1 et 1/2)
real nu=0.35;

//Coefficients de Lame
real lambda=E*nu/((1.+nu)*(1.-2.*nu));
real mu=E/(2.*(1.+nu));

// nu du fluide
real nuFluide=0.01;

// mesh density
real L = 1;
real Ly = L;
real Lx = 5*Ly;
real per = 0.7; // % of the Ly occupied by the fluid
real per2= 0.9; // % of the heigh of the curve

int N=9;
int Nx=N*Lx;
int Ny=N*Ly;

// Time step
real delta = 0.01;
 
//---------------------------------------------------------------------//
// Mesh
//---------------------------------------------------------------------//
border a(t=0,1){x=t*Lx; y = per*Ly + 0.03*sin(12*pi*t); label = 1;};
border b(t=per*Ly,Ly){x = Lx; y = t; label = 2;};
border c(t=1,0){x = Lx*t; y = Ly + 0.03*sin(12*pi*t); label = 3;};
border d(t=Ly, per*Ly){x = 0; y = t; label = 4;};
//---------------------------------------------------------------------//
border e(t=per*Ly, 0){x = 0; y = t; label = 5;};
border g(t=0,per*Ly){x = Lx; y = t; label = 7;};
//---------------------------------------------------------------------//
border h(t=0,-per*Ly){x = 0; y = t; label = 8;};
border j(t=0,1){x=t*Lx; y = -per*Ly + 0.03*sin(12*pi*t); label = 9;};
border k(t=-per*Ly, 0){x = Lx; y = t; label=10;};
//---------------------------------------------------------------------//
border l(t=-per*Ly, -Ly){x = 0; y = t; label=11;};
border m(t=0,1){x=t*Lx; y = -Ly + 0.03*sin(12*pi*t); label = 12;};
border o(t=-Ly, -per*Ly){x = Lx; y = t; label=13;};
//---------------------------------------------------------------------//
//
//---------------------------------------------------------------------//
border a1(t=0,1){x=(1+t)*Lx; y = per*Ly + per2*Ly*t^2; label=14;};
border b1(t=0,1){x=2*Lx; y = Ly*(per+per2+t*(1-per)); label=15;};
border c1(t=1,0){x=(1+t)*Lx; y = Ly + per2*Ly*t^2; label=16;};
//---------------------------------------------------------------------//
border d1(t=0,1){x=(1+t)*Lx; y = -per*Ly - per2*Ly*t^2;};
border e1(t=0,1){x=2*Lx; y = -(per2+per)*Ly*(1-t) - per*Ly*t;};
border f1(t=0,1){x=2*Lx-sin(t*pi)*per*Ly*5; y = -cos(t*pi)*per*Ly;};
border g1(t=0,1){x=2*Lx; y = (per+per2)*Ly*t + per*Ly*(1-t); label=17;};
//---------------------------------------------------------------------//
border h1(t=0,1){x=(1+t)*Lx; y = -Ly - per2*Ly*t^2;};
border i1(t=0,1){x=2*Lx; y = -(per2+1)*Ly*(1-t)-(per2+per)*Ly*t;};
//---------------------------------------------------------------------//
border j1(t=0,1){x=2*Lx; y = -per*Ly*(1-t) - (2*per-1)*Ly*t;};
border k1(t=0,1){x=2*Lx-sin(t*pi)*(2*per-1)*Ly*6; y = -cos(t*pi)*(2*per-1)*Ly;};
border l1(t=0,1){x=2*Lx; y = (2*per-1)*Ly*(1-t) + per*Ly*t;};
//---------------------------------------------------------------------//
mesh Th = buildmesh( a(Nx) + b(Ny*(1-per)) + c(Nx) + d(Ny*(1-per)) + e(Ny*per)
+ g(Ny*per) + h(Ny*per) + j(Nx) + k(Ny*per) + l(Ny*(1-per)) + m(Nx) + o(Ny*(1-per))
+ a1(Nx) + b1(Ny*(1-per)) + c1(Nx) 
+ d1(Nx) + e1(Ny*(per))+ f1(Nx) + g1(Ny*(per)) 
+ h1(Nx) + i1(Ny*(1-per))
+ j1(Ny*(2*per-1)) + k1(Nx) + l1(Ny*(2*per-1)));
mesh Sh = Th;

//---------------------------------------------------------------------//
// Espaces EF et fonctions discretes
//---------------------------------------------------------------------//
// Deformation
fespace Vh(Th,P1);

// Stokes
fespace Mh(Th, P1);

// Domain
fespace Zh(Th, P0);

Zh isSolid = ( region >= 8 ) + ( region <= 2);
Zh isFluid = ( region <= 8 ) * ( region >= 2);

plot([isSolid, isFluid]);

//coupled formula
Vh uh1, vh1;
Vh uh2, vh2;
Vh wh1, wh2;
Mh p,q;

wh1=0;
wh2=0;

int n=100;
func ff=0.01*(-y^2+(0.7*Ly)^2)*sin((i%n)*pi/80)*((i%n)<80);
//une fonction qui n’égale pas zéro si (i<#), égale zéro pour tout le reste de pas du temps. 
//La fonction est juste pour éviter Problem Couple2.

// Solves the coupled formula
problem Couple1(uh1, uh2, p, vh1, vh2, q, solver=LU) = 
    int2d(Th)((isFluid*nuFluide+isSolid*mu*delta)*(
    dx(uh1)*dx(vh1)+dy(uh1)*dy(vh1)+dx(uh2)*dx(vh2)+dy(uh2)*dy(vh2)
    +dx(uh1)*dx(vh1)+dx(uh2)*dy(vh1)+dy(uh1)*dx(vh2)+dy(uh2)*dy(vh2))
    -p*q*0.000001- isFluid*(p*dx(vh1)+p*dy(vh2))-dx(uh1)*q-dy(uh2)*q)
    +int2d(Th)((isSolid*mu*delta)*
    (dx(wh1)*dx(vh1)+dy(wh1)*dy(vh1)+dx(wh2)*dx(vh2)+dy(wh2)*dy(vh2)
    +dx(wh1)*dx(vh1)+dx(wh2)*dy(vh1)+dy(wh1)*dx(vh2)+dy(wh2)*dy(vh2))) //vient du deplacement de tour(i-1)
    +on(2, 4, uh1=0,uh2=0)
    +on(13, 11, uh1=0,uh2=0)
    +on(5, uh1=ff, uh2=0) 
    +on(8, uh1=ff, uh2=0) 
;
/*
for(i=0; i < 1000 ; i++) {

    cout << i << endl;
    Couple1;
    wh1=wh1+uh1;
    wh2=wh2+uh2;

    //plot(p);
    //plot( p, [uh1, uh2], wait=1);
    Th=movemesh(Th,[x,y+uh2*delta]);
    plot(movemesh(Th, [x, y+100*uh2]), p, [uh1, uh2]);
    //plot(movemesh(Th, [x, y+100*uh2*delta]));
    isSolid = ( region >= 8 ) + ( region <= 2);
    isFluid = ( region <= 8 ) * ( region >= 2);
}*/
